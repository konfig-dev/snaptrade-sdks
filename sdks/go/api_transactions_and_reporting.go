/*
SnapTrade

Connect brokerage accounts to your app for live positions and trading

API version: 1.0.0
Contact: api@snaptrade.com
*/

// Code generated by Konfig (https://konfigthis.com); DO NOT EDIT.

package snaptrade

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// TransactionsAndReportingApiService TransactionsAndReportingApi service
type TransactionsAndReportingApiService service

type TransactionsAndReportingApiGetActivitiesRequest struct {
	ctx context.Context
	ApiService *TransactionsAndReportingApiService
	userId string
	userSecret string
	startDate *string
	endDate *string
	accounts *string
	brokerageAuthorizations *string
	type_ *string
}

func (r *TransactionsAndReportingApiGetActivitiesRequest) StartDate(startDate string) *TransactionsAndReportingApiGetActivitiesRequest {
	r.startDate = &startDate
	return r
}

func (r *TransactionsAndReportingApiGetActivitiesRequest) EndDate(endDate string) *TransactionsAndReportingApiGetActivitiesRequest {
	r.endDate = &endDate
	return r
}

// Optional comma seperated list of account IDs used to filter the request on specific accounts
func (r *TransactionsAndReportingApiGetActivitiesRequest) Accounts(accounts string) *TransactionsAndReportingApiGetActivitiesRequest {
	r.accounts = &accounts
	return r
}

// Optional comma seperated list of brokerage authorization IDs used to filter the request on only accounts that belong to those authorizations
func (r *TransactionsAndReportingApiGetActivitiesRequest) BrokerageAuthorizations(brokerageAuthorizations string) *TransactionsAndReportingApiGetActivitiesRequest {
	r.brokerageAuthorizations = &brokerageAuthorizations
	return r
}

// Optional comma seperated list of types to filter activities by. This is not an exhaustive list, if we fail to match to these types, we will return the raw description from the brokerage. Potential values include - DIVIDEND - BUY - SELL - CONTRIBUTION - WITHDRAWAL - EXTERNAL_ASSET_TRANSFER_IN - EXTERNAL_ASSET_TRANSFER_OUT - INTERNAL_CASH_TRANSFER_IN - INTERNAL_CASH_TRANSFER_OUT - INTERNAL_ASSET_TRANSFER_IN - INTERNAL_ASSET_TRANSFER_OUT - INTEREST - REBATE - GOV_GRANT - TAX - FEE - REI - FXT
func (r *TransactionsAndReportingApiGetActivitiesRequest) Type_(type_ string) *TransactionsAndReportingApiGetActivitiesRequest {
	r.type_ = &type_
	return r
}

func (r TransactionsAndReportingApiGetActivitiesRequest) Execute() ([]UniversalActivity, *http.Response, error) {
	return r.ApiService.GetActivitiesExecute(r)
}

/*
GetActivities Get transaction history for a user

Returns activities (transactions) for a user. Specifying start and end date is highly recommended for better performance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId
 @param userSecret
 @return TransactionsAndReportingApiGetActivitiesRequest
*/
func (a *TransactionsAndReportingApiService) GetActivities(userId string, userSecret string) TransactionsAndReportingApiGetActivitiesRequest {
	return TransactionsAndReportingApiGetActivitiesRequest{
		ApiService: a,
		ctx: a.client.cfg.Context,
		userId: userId,
		userSecret: userSecret,
	}
}

// Execute executes the request
//  @return []UniversalActivity
func (a *TransactionsAndReportingApiService) GetActivitiesExecute(r TransactionsAndReportingApiGetActivitiesRequest) ([]UniversalActivity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniversalActivity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAndReportingApiService.GetActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

    subpath := "/activities"
	localVarPath := localBasePath + subpath
	if a.client.cfg.Host != "" {
		localVarPath = a.client.cfg.Scheme + "://" + a.client.cfg.Host + subpath
	}

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.accounts != nil {
		localVarQueryParams.Add("accounts", parameterToString(*r.accounts, ""))
	}
	if r.brokerageAuthorizations != nil {
		localVarQueryParams.Add("brokerageAuthorizations", parameterToString(*r.brokerageAuthorizations, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	localVarQueryParams.Add("userId", parameterToString(r.userId, ""))
	localVarQueryParams.Add("userSecret", parameterToString(r.userSecret, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["PartnerClientId"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("clientId", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["PartnerSignature"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Signature"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["PartnerTimestamp"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("timestamp", key)
			}
		}
	}

    prepareRequestBefore(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TransactionsAndReportingApiGetReportingCustomRangeRequest struct {
	ctx context.Context
	ApiService *TransactionsAndReportingApiService
	startDate string
	endDate string
	userId string
	userSecret string
	accounts *string
	detailed *bool
	frequency *string
}

// Optional comma seperated list of account IDs used to filter the request on specific accounts
func (r *TransactionsAndReportingApiGetReportingCustomRangeRequest) Accounts(accounts string) *TransactionsAndReportingApiGetReportingCustomRangeRequest {
	r.accounts = &accounts
	return r
}

// Optional, increases frequency of data points for the total value and contribution charts if set to true
func (r *TransactionsAndReportingApiGetReportingCustomRangeRequest) Detailed(detailed bool) *TransactionsAndReportingApiGetReportingCustomRangeRequest {
	r.detailed = &detailed
	return r
}

// Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly.
func (r *TransactionsAndReportingApiGetReportingCustomRangeRequest) Frequency(frequency string) *TransactionsAndReportingApiGetReportingCustomRangeRequest {
	r.frequency = &frequency
	return r
}

func (r TransactionsAndReportingApiGetReportingCustomRangeRequest) Execute() (*PerformanceCustom, *http.Response, error) {
	return r.ApiService.GetReportingCustomRangeExecute(r)
}

/*
GetReportingCustomRange Get performance information for a specific timeframe

Returns performance information (contributions, dividends, rate of return, etc) for a specific timeframe. Please note that Total Equity Timeframe and Rate of Returns are experimental features. Please contact support@snaptrade.com if you notice any inconsistencies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param startDate
 @param endDate
 @param userId
 @param userSecret
 @return TransactionsAndReportingApiGetReportingCustomRangeRequest

Deprecated
*/
func (a *TransactionsAndReportingApiService) GetReportingCustomRange(startDate string, endDate string, userId string, userSecret string) TransactionsAndReportingApiGetReportingCustomRangeRequest {
	return TransactionsAndReportingApiGetReportingCustomRangeRequest{
		ApiService: a,
		ctx: a.client.cfg.Context,
		startDate: startDate,
		endDate: endDate,
		userId: userId,
		userSecret: userSecret,
	}
}

// Execute executes the request
//  @return PerformanceCustom
// Deprecated
func (a *TransactionsAndReportingApiService) GetReportingCustomRangeExecute(r TransactionsAndReportingApiGetReportingCustomRangeRequest) (*PerformanceCustom, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PerformanceCustom
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAndReportingApiService.GetReportingCustomRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

    subpath := "/performance/custom"
	localVarPath := localBasePath + subpath
	if a.client.cfg.Host != "" {
		localVarPath = a.client.cfg.Scheme + "://" + a.client.cfg.Host + subpath
	}

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("startDate", parameterToString(r.startDate, ""))
	localVarQueryParams.Add("endDate", parameterToString(r.endDate, ""))
	if r.accounts != nil {
		localVarQueryParams.Add("accounts", parameterToString(*r.accounts, ""))
	}
	if r.detailed != nil {
		localVarQueryParams.Add("detailed", parameterToString(*r.detailed, ""))
	}
	if r.frequency != nil {
		localVarQueryParams.Add("frequency", parameterToString(*r.frequency, ""))
	}
	localVarQueryParams.Add("userId", parameterToString(r.userId, ""))
	localVarQueryParams.Add("userSecret", parameterToString(r.userSecret, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["PartnerClientId"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("clientId", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["PartnerSignature"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Signature"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["PartnerTimestamp"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("timestamp", key)
			}
		}
	}

    prepareRequestBefore(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
